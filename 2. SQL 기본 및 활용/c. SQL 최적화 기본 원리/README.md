---
과목2 SQL 기본 및 활용
3장 SQL 최적화 기본 원리
---

# 옵티마이저와 실행계획

1. 옵티마이저
   - 사용자가 질의한 SQL문에 대한 최적의 실행 방법을 결정하는 역할
   - 이 최적의 실행 방법을 실행계획이라 한다
   - 다양한 SQL 실행방법 중 최적의 실행 방법을 결정한다
   - 규칙 기반 옵티마이저와 비용기반 옵티마이저로 나뉜다
   - 대부분의 RDB에서는 비용기반 옵티마이저만을 제공한다
   - 규칙 기반 옵티마이저
     - 이용가능한 인덱스 유무,종류, 연산자의 종류, 참조하는 객체 등을 참조한다
     - 우선 순위가 높은 규칙이 적은 일량으로 해당 작업을 수행하는 방법이라고 판단한다
   - 비용 기반 옵티마이저
     - SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택하는 방식
     - 비용은 예상되는 소요시간, 자원 사용량을 의미한다
2. 실행계획(Execution Plan)
   - SQL에서 요구한 사항을 처리하기 위한 절차와 방법을 의미한다

# 인덱스 기본

1. 인덱스 특징과 종류
   - 인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념
   - 테이블을 기반으로 선택적으로 생성할 수 있는 구조
   - 검색 성능의 최적화가 기본적인 목적
   - Insert,Update,Delete 등은 오히려 느릴수 있다
2. 트리 기반 인덱스

   - B-트리 인덱스
     - 가장 일반적인 인덱스
       - 루트-브랜치-리프 블록으로 구성
       - 브랜치
         - 다음 단계의 블록을 가리키는 포인터를 가지고 있다
       - 리프
         - 인덱스를 구성하는 칼럼의 데이터와 해당 데이터를 가지고 있는 행의 위치를 가리키는 레코드 식별자를 가지고 있다
         - 양방향 링크를 가지고 있어서 ASC,DESC 검색을 쉽게 할수 있다

3. 클러스터형 인덱스
   - 인덱스의 리프 페이지가 곧 데이터 페이지다
     - 따라서 식별자가 리프페이지에 없다
     - 해당 테이블의 모든 칼럼값을 리프페이지에서 곧바로 얻을 수 있다
   - 리프 페이지의 모든 로우는 키 인덱스-키-칼럼 순으로 물리적으로 정렬되어 저장된다
     - 따라서 테이블당 하나만 생성할 수 있다
4. 전체 테이블 스캔과 인덱스 스캔
   - 전체 테이블 스캔
     - 테이블의 모든 데이터를 읽어가면서 조건과 비교하는 방법
     - 시간이 오래 걸릴 수 있다
     - 이렇게 읽은 '모든 블록'은 재사용성이 떨어진다
       - 따라서 읽은 블록들은 메모리에서 바로 제거되도록 관리된다
   - 인덱스 스캔
     - 인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 액세스 기법
     - 인덱스의 리프블록을 읽으면 인덱스 구성 칼럼과 테이블의 레코드 식별자를 알 수 있다
     - 인덱스에 존재하지 않는 칼럼의 값이 필요한 경우
       - 레코드 식별자를 이용해 테이블에 액세스
     - 모든 칼럼이 인덱스 구성 칼럼에 포함된경우
       - 테이블 액세스가 발생하지 않는다
   - 전체 테이블 스캔과 인덱스 스캔 방식의 비교
     - 인덱스 스캔은 한번의 I/O 요청에 한 블록씩 데이터를 읽는다
     - 전체 테이블 스캔은 여러블록을 한꺼번에 읽는다
     - 테이블의 모든 데이터를 읽을것이라면 전체 테이블 스캔이 유리하다
     - 한편 극히 일부의 데이터를 읽어야 할때는 인덱스 스캔을 통해 몇번의 I/O로 원하는 데이터를 쉽게 찾을 수 있다

# 조인 수행 원리

- A,B,C 세개 테이블을 조인할 때
  - A와 B 테이블을 조인하면 그 결과를 나머지 C와 조인한다

1. NL JOIN
   - 반복문과 유사한 방식으로 조인을 수행한다
   - 반복문 외부의 테이블을 선행 테이블, outer table
   - 내부의 테이블을 후행 테이블,inner table이라 한다
   1. 선행 테이블의 조건을 만족하는 행을 추출한다
   2. 후행 테이블을 읽으면서 조인을 수행한다
   3. 선행 테이블의 조건을 만족하는 모든 행에 1번작업 반복수행
   - 결과 행의 수가 적은 테이블을 선행 테이블로 선택하는 것이 전체 태스크량을 줄이는 방법이다
2. Sort Merge JOIN
   - 조인 칼럼을 기준으로 데이터를 정렬하여 조인을 수행한다
   - 스캔 방식으로 데이터를 읽는다
   - 정렬을 한 후 조인을 하기 때문에 넓은 범위의 데이터를 처리할 때 이용되던 조인기법이다
   - 모든 정렬 작업을 수행하기 어려운 경우에는 디스크를 사용하기 때문에 성능이 저하될수 있다
   - 대량의 조인 작업에서 정렬 작업이 필요할때는 오히려 Hash JOIN이 성능상유리하다
   1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾는다
   2. 선행 테이블의 조인 키를 기준으로 정렬 작업
   3. 1~2번 작업을 선행 테이블의 조건을 만족하는 모든 행에 반복 수행
   4. 후행 테이블에서 주어진 조건을 만족하는 행을 찾는다
   5. 후행 테이블의 조인 키를 기준으로 정렬 작업
   6. 3~4번 작업을 후행 테이블의 조건을 만족하는 모든 행에 반복 수행
   7. 정렬된 결과를 이용하여 조인 수행
   - 항상 정렬 작업이 발생하는 것은 아니다
   - 앞의 작업을 수행하던 중 정렬이 이미 이루어졌다면 조인을 위한 정렬 작업은 발생하지 않는다
3. Hash JOIN
   1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음
   2. 선행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테이블을 생성 → 조인 칼럼과 SELECT 절에서 필요로 하는 칼럼도 함께 저장됨
   3. 1 ~ 2번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행 3 후행 테이블에서 주어진 조건을 만족하는 행을 찾음
   4. 후행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음 → 조인 키를 이용해서 실제 조인될 데이터를 찾음
   5. 조인에 성공하면 추출버퍼에 넣음
   6. 3 ~ 5번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해서 반복 수행
   - 동등 조건에서만 사용할 수 있다
   - 해쉬 테이블을 메모리에 생성해야 한다
   - 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다
